# A-MEM: Autonomous Memory System for Cambrian Agents\n\nThis document explains how to use the A-MEM system that has been integrated into the Cambrian Agent Kit.\n\n## System Architecture\n\nThe A-MEM system consists of three main components:\n\n1. **Memory Manager**: The core component that handles storing and retrieving memories\n2. **Database Connectors**: Interfaces to Neo4j (graph database), ChromaDB (vector database), and Supabase (relational database)\n3. **Intelligence Engine**: A background service that runs scheduled tasks to reflect on memories and generate insights\n\n## Setting Up the System\n\n1. **Environment Variables**: Copy `.env.example` to `.env` and fill in your database credentials\n2. **Docker Services**: Run `docker-compose up -d` to start the Neo4j and ChromaDB services\n3. **Dependencies**: Run `pnpm install` to install all required dependencies\n\n## Using the Memory System\n\n### Creating a Memory Manager\n\n```typescript\nimport { MemoryManager } from './src/memory/manager';\n\nconst memoryManager = await MemoryManager.create();\n```\n\n### Adding Memories\n\n```typescript\nconst memoryId = await memoryManager.addMemory({\n  content: 'Successfully swapped 100 USDC for 0.1 ETH on Symphony.',\n  type: 'transaction_record',\n  importance: 0.8,\n  metadata: {\n    userId: 'user_123',\n    protocol: 'Symphony',\n    fromToken: 'USDC',\n    toToken: 'ETH',\n    hash: '0x123456789abcdef',\n  },\n});\n```\n\n### Retrieving Memories\n\n```typescript\nconst memories = await memoryManager.retrieveMemories('token swap', 5);\n```\n\n## Memory-Enabled Tools\n\nThe system includes wrapped versions of existing tools that automatically record actions as memories:\n\n```typescript\nimport { SeiSwapToolWithMemory } from \"./src/memory/wrapped-tools/symphony\";\n\nconst tools = [\n  new SeiSwapToolWithMemory(agentInstance, memoryManager, \"user_123\"),\n];\n```\n\n## Intelligence Engine\n\nThe intelligence engine runs scheduled tasks to reflect on memories:\n\n```bash\ncd intelligence-engine\nnpm start\n```\n\nBy default, it runs a nightly reflection at 2 AM that:\n1. Retrieves recent, important memories\n2. Generates insights using an LLM\n3. Saves reflections as high-importance memories\n\n## Retrieval Augmented Generation (RAG)\n\nThe system includes a RAG implementation that retrieves relevant memories and includes them in the agent's prompt:\n\n```typescript\nconst ragChain = RunnableSequence.from([\n  {\n    input: new RunnablePassthrough(),\n    memory: async (input: { input: string }) => {\n      const memoryManager = await MemoryManager.create();\n      const memories = await memoryManager.retrieveMemories(input.input);\n      return memories.map(m => `[${m.type}]: ${m.content}`).join('\\n');\n    },\n  },\n  promptTemplate,\n  llm,\n]);\n```\n\n## Testing\n\nSeveral test scripts are included:\n\n- `pnpm test-memory`: Tests the memory manager with mock databases\n- `pnpm test-memory-agent`: Tests an agent with memory-enabled tools\n- `pnpm test-rag-agent`: Tests an agent with RAG capabilities\n\n## Future Enhancements\n\n1. **Embedding Generation**: Implement actual embedding generation using OpenAI's text-embedding-ada-002 or local models\n2. **Memory Importance Calculation**: Develop algorithms to automatically calculate memory importance\n3. **Advanced Graph Queries**: Implement more complex graph queries for relationship discovery\n4. **Memory Consolidation**: Add mechanisms to consolidate and summarize memories over time\n5. **Multi-user Support**: Extend the system to handle multiple users with isolated memory stores\n